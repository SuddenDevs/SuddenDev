{% extends "base.html" %}
{% block head %}
  <link rel="stylesheet" type="text/css" href="{{url_for('static', filename='style_game.css')}}">
  <script type="text/javascript" src="{{url_for('static', filename='src-min-noconflict/ace.js')}}"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
  <script type="text/javascript" src="{{url_for('static', filename='pixi-particles.min.js')}}"></script>

  <script>
      //Colors and static variables
      var ENEMYC = "#000000";
      var PICKUPC = "#edd95c";
      var COREC = "#47d7f7";
      var NAMEOFFS = 10;
      var EDITFONTSIZE = 15;
      var FRAMERATE = 60;
      var WAITTEXT = "Press ready to begin!";
      var MAXPLAYERS = 4;
      var EVENTS = {"CONNECT":'connect',"PLAYERID":'player_id',
                    "RESULT":'result',"UPDATE":'update',"TEST":'test',
                    "SUBMIT":'submit',"LEFT":'left',"JOINED":'joined',
                    "PLAY":'play', "ERROR":'message_error',
                    "ROOM_MSG":"message_room", "GAME_RESULT":'message_result'};

      var editor = null;
      var socket = null;
      var inGame = false;
      var test = false;
      var currentTab = 0;
      var scripts = [`{{user.script}}`,"","",""];

      //Stage/shape drawer initialised, can be used in multiple functions
      var stage = null;
      var renderer = null
      var fpsText = null;
      var waitingText = null;
      var players = [];
      var playerID = {{user.id}};

      //Game state
      var ticker = null;
      var playerDict = {};
      var enemies = {};
      var pickups = {};
      var attacks = [];
      var core = null;
      var timer = 0;

      var states = [];

      //Game parameters
      var attack_fade = 0.2;

      //Initialise connection to server
      function initSocket() {
        $(document).ready(function(){
          socket = io.connect('http://' + document.domain + ':' + location.port + '/game-session');
          socket.on(EVENTS.CONNECT, function() {
            connectToGame();
          });
          socket.on(EVENTS.PLAYERID, function(data) {
            playerID = parseInt(data);
          });
          socket.on(EVENTS.RESULT, function(data) {
            readyGame(data);
          });
          socket.on(EVENTS.UPDATE, function(data) {
            updateRoom(data);
          });
          socket.on(EVENTS.ROOM_MSG, function(data) {
            printToConsole(data, "#00F");
          });
          socket.on(EVENTS.ERROR, function(data) {
            printToConsole(data, "#F00");
          });
          socket.on(EVENTS.GAME_RESULT, function(data) {
            printToConsole(data, "#0F0");
          });
        });
        window.onbeforeunload = function(e) {
            socket.emit(EVENTS.LEFT, {});
            socket.disconnect();
        }
      }

      //Tell the server when the player has joined
      function connectToGame() {
        socket.emit(EVENTS.JOINED, {});
      }

      //Function to start the game
      function readyGame(data) {
        var tempStates = JSON.parse(data).result;
        for (i = 0; i < tempStates[0].events.length; i++) {
          if (tempStates[0].events[i].name === "Game_Start") {
            clearStates();
            break;
          }
        }
        states = states.concat(tempStates);
        stage.removeChild(waitingText);
        for (i = 0; i < players.length; i++) {
          create_player(states[0].players[i]);
        }
        timer = 0;
        create_core(states[0].core);
        inGame = true;
        if (test) {
          toggleClasses("testBtn", ["inactive", "noEvents"], false);
          toggleClasses("readyBtn", ["inactive", "noEvents"], false);
        }
        ticker.start();
      }

      var health_bar_width = 24;
      function create_health_bar() {
        var red = new PIXI.Graphics();
        var green = new PIXI.Graphics();
        var width = health_bar_width;
        var height = 4;
        var radius = 2;
        red.beginFill(0xff0000);
        red.lineStyle(2, 0x0, 0);
        green.beginFill(0x00ff00);
        red.drawRoundedRect(0, 0, width, height, radius);
        green.drawRoundedRect(0, 0, width, height, radius);

        var health = new PIXI.Container();
        health.addChildAt(red, 0);
        health.addChildAt(green, 1);
        return health;
      }

      function create_entity_triangle(data) {
        var container = new PIXI.Container();
        var sprite = create_triangle({x:0, y:0}, data.vel, data.size, data.color);
        container.addChild(sprite);

        var health = create_health_bar();
        health.y = data.size + 2;
        health.x = -health.width/2;
        container.addChild(health);

        container.position = data.pos;
        stage.addChild(container);
        return {
          container: container,
          sprite: sprite,
          health: health
        };
      }

      function create_player(data) {
        playerDict[data.tag] = create_entity_triangle(data);

        var ammo = new PIXI.Text(data.ammo.toString(),
                                        { fontFamily: "Arial",
                                          fontSize: 12,
                                          fill: "black",
                                          align: "center"});
        ammo.anchor.x = 0.5;
        ammo.anchor.y = -1.5;
        ammo.y = -data.size/2 - 2;

        var name = new PIXI.Text(data.name,
                                        { fontFamily:"Arial",
                                          fontSize:"12", 
                                          fill: "black"});
        name.anchor.x = 0.5;
        name.anchor.y = 2;
        playerDict[data.tag].container.addChild(ammo);
        playerDict[data.tag].container.addChild(name);
        playerDict[data.tag].ammo = ammo;
        playerDict[data.tag].name = name;
      }

      function create_core(data) {
        var container = new PIXI.Container();
        var sprite = new PIXI.Graphics();
        var size = 10;

        sprite.beginFill(PIXI.utils.rgb2hex([0, 1, 1]));
        sprite.drawCircle(0, 0, size);
        container.addChild(sprite);

        var health = create_health_bar();
        // console.log(health.width);
        health.y = data.size + 2;
        health.x = -health_bar_width/2;
        container.addChild(health);

        container.position = data.pos;
        stage.addChild(container);

        core = {
          container: container,
          sprite: sprite,
          health: health
        };
      }

      function create_attack(from, to) {
        var graphics = new PIXI.Graphics();
        var width = 2;
        graphics.lineStyle(2, PIXI.utils.rgb2hex([1, 0, 0]));
        graphics.moveTo(from.x, from.y);
        graphics.lineTo(to.x, to.y);
        stage.addChild(graphics);
        attacks.push({sprite: graphics,
                      timer: 0});
      }

      function create_enemy(data) {
        data.color = ENEMYC;
        enemies[data.tag] = create_entity_triangle(data);
      }

      function create_powerup(data) {
        var container = new PIXI.Container();
        var sprite = new PIXI.Graphics();
        var size = 10;

        sprite.beginFill(PIXI.utils.rgb2hex([1, 0, 1]));
        sprite.drawRect(0, 0, size, size);
        sprite.x = -size/2;
        sprite.y = -size/2;
        sprite.pivot.x = size/2;
        sprite.pivot.y = size/2;
        container.addChild(sprite);

        var label = new PIXI.Text(data.value.toString(),
                                              { fontFamily:"Arial",
                                                fontSize:"12",
                                                fill: "black",
                                                align: "center" });
        label.anchor.y = 1;
        label.anchor.x = 0.5;
        label.y = -size/2 - 2;
        container.addChild(label);

        container.position = data.pos;
        stage.addChild(container);

        var emitter = new PIXI.particles.Emitter(
                container,
                [sprite.generateCanvasTexture(new PIXI.Point(1,1), 1)],
                {
                        alpha: {
                                start: 0.8,
                                end: 0.1
                        },
                        scale: {
                                start: 2,
                                end: 0.3
                        },
                        speed: {
                                start: 200,
                                end: 100
                        },
                        lifetime: {
                                min: 2,
                                max: 2
                        },
                        frequency: 40,
                        emitterLifetime: 10,
                        maxParticles: 1000,
                        pos: {
                                x: 0,
                                y: 0
                        },
                        addAtBack: false,
                        spawnType: "circle",
                        spawnCircle: {
                                x: 0,
                                y: 0,
                                r: 10
                        }
                }
        );

        pickups[data.tag] = {
          container: container,
          sprite: sprite,
          emitter: emitter,
          label: label
        };
      }

      function clearup_powerup(tag) {
        stage.removeChild(pickups[tag]);
        delete pickups[tag];
      }

      function clearup_player(tag) {
        stage.removeChild(playerDict[tag].container);
        delete playerDict[tag];
      }

      function clearup_enemy(tag) {
        stage.removeChild(enemies[tag].container);
        delete enemies[tag];
      }

      function find_entity(tag) {
        //Players
        if (tag in playerDict) {
          return playerDict[tag];
        } else if (tag in enemies) {
          return enemies[tag];
        } else if (core.tag == tag) {
          return core;
        }
        return null;
      }

      //Update player details/scripts
      function updateRoom(data) {
        var room = JSON.parse(data);

        //Check if players have joined
        for (i = 0; i < room.players.length; i++) {
          tryAddPlayer(room.players[i]);
          if (i != 0) {
            scripts[i] = players[i].script;
          }
        }

        //Check if players have left
        if (players.length > room.players.length) {
          for (i = 0; i < players.length; i++) {
            var present = false;
            for (j = 0; j < room.players.length; j++) {
              if (players[i].id == room.players[j].id) {
                present = true;
              }
            }
            if (!present) {
              players.splice(i, 1);
              i--;
            }
          }
        }
      }

      //If a player isn't already stored then store their details
      function tryAddPlayer(player) {
        if (havePlayer(player.id)) {
          return false;
        }
        players.push(player);
        var t = document.getElementById("tab" + (players.length - 1));
        t.innerHTML = player.name;
        scripts[players.length - 1] = player.script;
        if (t.classList.contains("hidden")) {
          t.classList.remove("hidden");
          if (players.length - 1 == 0) {
            editor.setValue(scripts[0]);
          }
        }
        return true;
      }

      //Function to tell if a player id is already present in the room
      function havePlayer(id) {
        for (i = 0; i < players.length; i++) {
          if (players[i].id == id) {
            return true;
          }
        }
        return false;
      }

      function draw() {
        renderer.render(stage);
      }

      //Tell server that the client is leaving
      function exitGame(e) {
        socket.emit(EVENTS.LEFT, {});
        socket.disconnect();
      }

      function submitCode() {
        if (editor.getValue() !== scripts[0]) {
          //console.log("saved");
          scripts[0] = editor.getValue();
          socket.emit(EVENTS.SUBMIT, scripts[0]);
        }
      }

      function testCode() {
        clearStates();
        socket.emit(EVENTS.TEST, editor.getValue());
        toggleClasses("testBtn", ["noEvents", "inactive"], true);
        toggleClasses("readyBtn", ["noEvents", "inactive"], true);
        test = true;
      }

      function revertCode() {
        editor.setValue(scripts[0]);
      }

      function clearStates() {
        playerDict = {};
        enemies = {};
        pickups = {};
        core = null;
        states = [];
        inGame = false;
        for (i = stage.children.length - 1; i >= 0; i--) {
          stage.removeChild(stage.children[i]);
        }
      }

      //Function to leave the game
      function leaveGame() {
        window.location.href = "{{ url_for('main.lobby') }}";
      }

      //Ready up
      function readyUp() {
        toggleClasses("readyBtn", ["active", "noEvents"], true);
        toggleClasses("testBtn", ["noEvents","inactive"], true);
        socket.emit(EVENTS.PLAY, {});
        test = false;
      }

      //Initialise gameCanvas - initialise stage, add shape drawer
      function initCanvas() {
        ticker = new PIXI.ticker.Ticker();
        ticker.add(game_loop);

        var canvas = document.getElementById("gameCanvas");
        renderer = PIXI.autoDetectRenderer(800, 600, {view: canvas, antialias: true});
        stage = new PIXI.Container();
        renderer.backgroundColor = 0xffffff;

        waitingText = new PIXI.Text(WAITTEXT, {fontFamily: "Arial", fontSize: 20, fill: "black"});
        waitingText.x = 400;
        waitingText.y = 200;
        waitingText.anchor.x = 0.5;
        stage.addChild(waitingText);

        fpsText = new PIXI.Text("", {fontFamily: "Arial", fontSize: 20, fill: "black"});
        fpsText.x = 10;
        fpsText.y = 10;
        stage.addChild(fpsText);
        renderer.render(stage);
      }

      function game_loop() {
        delta = ticker.elapsedMS/1000;
        timer += delta;
        fpsText.text = Math.round(ticker.FPS * 100) / 100;
        if (inGame && states.length > 0) {
          process_state(states[0]);
          states.splice(0, 1);
        }

        //Effects
        draw_attacks(delta);

        draw();
      }

      //Clear shape drawer, then draw game state to gameCanvas
      function process_state(state, delta) {
        //Process events
        //Create & delete entities

        var events = state.events;
        for (i = 0; i < events.length; i++) {
          var e = events[i];
          var body = e.body;
          switch (e.name) {
            case "Enemy_Spawn":
              create_enemy(body);
              break;
            case "Enemy_Death":
              clearup_enemy(body.tag);
              break;
            case "Powerup_Spawn":
              create_powerup(body);
              break;
            case "Powerup_Used":
              clearup_powerup(body.tag);
              break;
            case "Game_End":
              // console.log('RIP game');
              endGame();
              break;
            case "Attack":
              create_attack(body[0].pos, body[1].pos);
              break;
            case "Print":
              printToConsole(body, "#F0F");
              break;
            case "Error":
              printToConsole(body, "#F00");
              break;
            default:
              //console.log("Unknown event: " + e.name);
          }
        }

        //Update
        draw_enemies(state.enemies);
        draw_pickups(state.powerups, delta);
        draw_players(state.players);
        draw_core(state.core);
      }

      function endGame() {
        ticker.stop();
        if (!test) {
          toggleClasses("readyBtn", ["active", "noEvents"], false);
          toggleClasses("testBtn", ["inactive", "noEvents"], false);
        } else {
          test = false;
        }
      }

      function vector_to_rotation(dir) {
        return Math.atan2(dir.y, dir.x) + Math.PI/6;
      }

      function draw_attacks(delta) {
        for (i = 0; i < attacks.length; i++) {
          var a = attacks[i];
          a.timer = a.timer + delta;
          if (a.timer >= attack_fade) {
            stage.removeChild(a.sprite);
            attacks.splice(i, 1);   
            i--;
          } else {
            a.sprite.alpha = 1 - a.timer/attack_fade;
          }
        }
      }

      function draw_core(data) {
        core.health.getChildAt(1).scale.x = data.health/data.healthMax;
      }

      //Create equilateral triangle facing DIR
      function create_triangle(pos, dir, radius, color) {
        var shape = new PIXI.Graphics();
       
        var base = 2 * radius * Math.cos(Math.PI/6);
        var height = radius * (1 +  Math.sin(Math.PI/6));
        
        shape.beginFill(color);
        shape.drawPolygon([0, 0, base, 0, base/2, height]);
        shape.endFill();

        shape.rotation = vector_to_rotation(dir);
        shape.x = pos.x;
        shape.y = pos.y;
        shape.pivot.x = 0.5 * base;
        shape.pivot.y = 1/3 * height;

        return shape;
      }

      function update_entity(entity, data) {
        entity.container.position = data.pos;
        if (data.vel.x != 0 || data.vel.y != 0) {
          entity.sprite.rotation = vector_to_rotation(data.vel);
          entity.health.getChildAt(1).scale.x = data.health/data.healthMax;
        }
      }

      // Draw every object in a list the same color
      function draw_enemies(list) {
        for (i = 0; i < list.length; i++) {
          update_entity(enemies[list[i].tag], list[i]);
        }
      }

      // Draw every player and update name locations
      function draw_players(list) {
        for (i = 0; i < list.length; i++) {
          var data = list[i];
          var player = playerDict[data.tag];
          update_entity(player, data);
          player.ammo.text = data.ammo.toString();
        }
      } 

      function draw_pickups(list, delta) {
        for (i = 0; i < list.length; i++) {
          var p = pickups[list[i].tag];
          p.sprite.rotation = (timer * 20) % 20;
          p.emitter.update(delta);
        }
      }

      //Pause game, update pause button
      function togglePause() {
        if (ticker.started && inGame) {
          ticker.stop();
        } else {
          ticker.start();
        }
        var b = document.getElementById("pauseBtn");
        b.innerHTML = (ticker.started) ? "Unpause" : "Pause";
        b.classList.toggle("active");
      }

      function setEditorTab(tabi) {
        var tabs = document.getElementsByClassName("tabBtn");
        tabs[currentTab].classList.toggle("active");
        tabs[tabi].classList.toggle("active");
        scripts[currentTab] = editor.getValue();
        editor.setValue(scripts[tabi]);
        editor.focus();
        currentTab = tabi;
      }

      //Initialise the editor
      function initEditor() {
        editor = ace.edit("editor");
        editor.$blockScrolling = Infinity;
        editor.getSession().setMode("ace/mode/python");
        editor.getSession().setUseWrapMode(true);
        editor.getSession().setTabSize(4);
        editor.getSession().setUseSoftTabs(true);
        editor.setValue(scripts[0], 1);
      }

      //Prints to the on screen console
      function printToConsole(data, color){
        var c = document.getElementById("console");
        var s = document.createElement("span");
        s.innerHTML = data + "\n";
        s.classList.add("console");
        s.style.color = color;
        c.appendChild(s);
        c.scrollTop = c.scrollHeight;
      }

      function toggleClasses(id, classes, add) {
        var e = document.getElementById(id).classList;
        for (i = 0; i < classes.length; i++) {
          if (add) {
            e.add(classes[i]);
          } else {
            e.remove(classes[i]);
          }
        }
      }

    </script>
{% endblock %}
{% block body %}
  
    <div id="title" class="title">
      <img src="{{ url_for('static', filename='logo_64.png')}}">
      <h1 id="heading" class="mainHeading">   S U D D E N _ D E V</h1>
    </div>
    <div class="container-fluid mainGrid">
      <div class="row mainRow">
        <div class="col mainCol gameCol">
          <div id="gameDiv" class="game greyBorder">
            <canvas id="gameCanvas" class="game" width="800px"
                    height="600px"></canvas>
            <div class="controls greyBorder">
              <button class="controls" onclick="leaveGame()">Leave Game</button>
              <button class="controls" onclick="submitCode()">Save Code</button>
              <button id="readyBtn" class="controls" onclick="readyUp()">Ready</button>
              <button id="testBtn" class="controls" onclick="testCode()">Test Code</button>
              <button id="pauseBtn" class="controls" onclick="togglePause()">Pause</button>
                </button>
            </div>
          </div>
        </div>
        <div class="col mainCol editCol">
          <div class="greyBorder">
            <div id="editor"></div>
          </div>
          <div class="controls">
            <button class="controls" onclick="revertCode()">Revert</button>
            <button class="controls" onclick="printToConsole(editor.getValue(), '#000')">Print</button>
            <button id="tab0" class="controls tabBtn active hidden" onclick="setEditorTab(0)">Player1</button>
            <button id="tab1" class="controls tabBtn hidden" onclick="setEditorTab(1)">Player2</button>
            <button id="tab2" class="controls tabBtn hidden" onclick="setEditorTab(2)">Player3</button>
            <button id="tab3" class="controls tabBtn hidden" onclick="setEditorTab(3)">Player4</button>
          </div>
        </div>
      </div>
      <div class="row detailRow">
        <div class="container-fluid detailGrid greyBorder">
          <div class="row inDetailRow">
            <div class="col-sm detailCol">
              <div id="console" class="console"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script>initCanvas();initSocket();initEditor();</script>
{% endblock %}
  
