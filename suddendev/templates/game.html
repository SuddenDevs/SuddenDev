{% extends "base.html" %}
{% from 'macros.html' import suddendev_logged_in_header_game %}

{% block head %}
  <link rel="stylesheet" type="text/css" href="{{url_for('static', filename='style_game.css')}}">
  <script type="text/javascript" src="{{url_for('static', filename='src-min-noconflict/ace.js')}}"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.5.1/pixi.min.js"></script>
  <script type="text/javascript" src="{{url_for('static', filename='pixi-particles.min.js')}}"></script>
  <script type="text/javascript" src="{{url_for('static', filename='pixi-extra-filters.min.js')}}"></script>

  <script>
      //Colors and static variables
      var ENEMYC = "#000000";
      var PICKUPC = "#edd95c";
      var COREC = "#47d7f7";
      var NAMEOFFS = 10;
      var EDITFONTSIZE = 15;
      var FRAMERATE = 60;
      var WAIT_TEXT = "Room Key: {{ game_id }}";
      var INTRO_TEXT = "Press Test Code to test your script, or Start Game when your script is ready";
      var MAXPLAYERS = 4;
      var HEALTHBARWIDTH = 24;
      var TIME_AFTER_END = 2; //How long to continue animating after round
      var MSG_DISPLAY_TIME = 4;
      var TAB_NAME_CHAR_LIMIT = 16;
      var EVENTS = {"CONNECT":'connect',"PLAYERID":'player_id',
                    "RESULT":'result',"UPDATE":'update',"TEST":'test',
                    "SUBMIT":'submit',"LEFT":'left',"JOINED":'joined',
                    "PLAY":'play', "ERROR":'message_error',
                    "ROOM_MSG":"message_room", "GAME_RESULT":'message_result',
                    "TROPHY":"message_trophy", "LOCAL":'message_local',
                    "CHAT":"message_chat", "CANCEL":'cancel'};

      var editor = null;
      var socket = null;
      var inGame = false;
      var test = false;
      var ready = false;
      var currentTab = 0;
      var playerID = {{user.id}};
      var players = [];
      var trophyQueue = [];

      //Stage/shape drawer initialised, can be used in multiple functions
      var stage = null;
      var textStyle = null;
      var renderer = null
      var fpsText = null;
      var mainText = null;
      var introText = null;

      //Layers
      var hud_layer = null;
      var game_layer = null;
      var background_layer = null;

      //Game state
      var ticker = null;
      var playerDict = {};
      var enemies = {};
      var pickups = {};
      var attacks = [];
      var core = null;
      var timer = 0;
      var last_state = null;
      var timer_end = 0;

      var game_data = [];
      var game_data_current = [];
      var wave_current = null;

      //Game parameters
      var attack_fade = 0.2;

      //Initialise connection to server
      function initSocket() {
        $(document).ready(function(){
          socket = io.connect('http://' + document.domain + ':' + location.port + '/game-session');
          socket.on(EVENTS.CONNECT, function() {
            connectToGame();
          });
          socket.on(EVENTS.PLAYERID, function(data) {
            console.log("received id: " + parseInt(data).toString());
            console.log("vs : " + playerID.toString());
            playerID = parseInt(data);
          });
          socket.on(EVENTS.RESULT, function(data) {
            data_receive(data);
          });
          socket.on(EVENTS.UPDATE, function(data) {
            updateRoom(data);
          });
          socket.on(EVENTS.ROOM_MSG, function(data) {
            printToConsole("[ROOM]: " + data, "#00F");
          });
          socket.on(EVENTS.LOCAL, function(data) {
            printToConsole("[LOCAL]: " + data, "#666");
          })
          socket.on(EVENTS.ERROR, function(data) {
            printToConsole("[ERR]: " + data, "#F00");
          });
          socket.on(EVENTS.GAME_RESULT, function(data) {
            printToConsole("[RES]: " + data, "#0F0");
          });
          socket.on(EVENTS.TROPHY, function(data) {
            trophyQueue.push(data);
          });
          socket.on(EVENTS.CHAT, function(data){
            handleChatIn(data);
          });
        });
        window.onbeforeunload = function(e) {
            socket.emit(EVENTS.LEFT, {});
            socket.disconnect();
        }
      }

      //Tell the server when the player has joined
      function connectToGame() {
        socket.emit(EVENTS.JOINED, {});
      }

      //Handle new batch of game data
      function data_receive(data) {
        var data_new = JSON.parse(data).result;
        var first = data_new[0];
        var game_is_new = false;
        if (!test) {
          toggleClasses("readyBtn", ["active", "noEvents"], true);
          toggleClasses("testBtn", ["greyOut", "noEvents"], true);
          document.getElementById("readyBtn").innerHTML = "Playing"
        } else {
          toggleClasses("testBtn", ["active"], true);
          toggleClasses("readyBtn", ["greyOut", "noEvents"], true);
        }

        //Check if this is a new game
        for (var i = 0; i < first.events.length; i++) {
          if (first.events[i].name === "Game_Start") {
            game_is_new = true;
            break;
          }
        }
        if (game_is_new) {
            game_data.push(data_new);
            if (!inGame) {
              game_start();
            }
        } else {
          var top = game_data[game_data.length - 1];
          Array.prototype.push.apply(top, data_new);
        }
      }

      function startWaiting(state) {
        var style = new PIXI.TextStyle({
          fontFamily: 'Arial',
          fontSize: 36,
          fontWeight: 'bold',
          fill: ['#ffffff'], // gradient
          align: 'center',
          strokeThickness: 5,
          dropShadow: true,
          dropShadowColor: '#000000',
          dropShadowBlur: 10,
          dropShadowAlpha: 0.5,
          dropShadowAngle: Math.PI / 6,
          dropShadowDistance: 1,
          wordWrap: true,
          wordWrapWidth: 700
        });

        var style2 = new PIXI.TextStyle({
          fontFamily: 'Arial',
          fontSize: 30,
          fill: ['#ffffff'], // gradient
          align: 'center',
          strokeThickness: 3,
          dropShadow: true,
          dropShadowColor: '#000000',
          dropShadowBlur: 10,
          dropShadowAlpha: 0.25,
          dropShadowAngle: Math.PI / 6,
          dropShadowDistance: 1,
          wordWrap: true,
          wordWrapWidth: 600
        });

        mainText = new PIXI.Text(INTRO_TEXT, style);
        mainText.x = 400;
        mainText.y = 200;
        mainText.anchor.x = 0.5;

        introText = new PIXI.Text(WAIT_TEXT, style2);
        introText.x = 400;
        introText.y = 500;
        introText.anchor.x = 0.5;

        hud_layer.addChild(mainText);
        hud_layer.addChild(introText);
      }

      function draw_grid() {
        //Grid
        var cell_size = 20;
        var across = renderer.width / cell_size;
        var up = renderer.height / cell_size;
        var grid = new PIXI.Graphics();
        grid.lineStyle(1, "black", 0.1);
        //Vertical
        for (var i = 0; i < across; i++) {
          grid.moveTo(i * cell_size, 0);
          grid.lineTo(i * cell_size, renderer.height);
        }
        //Horizontal
        for (var i = 0; i < across; i++) {
          grid.moveTo(0, i * cell_size);
          grid.lineTo(renderer.width, i * cell_size);
        }

        grid.lineStyle(2, "black", 0.15);
        grid.moveTo(0,0);
        grid.lineTo(renderer.width, 0);
        grid.lineTo(renderer.width, renderer.height);
        grid.lineTo(0, renderer.height);
        grid.lineTo(0, 0);

        background_layer.addChildAt(grid, 0);
      }

      function game_start() {
        clear_current_game_data();
        fade.visible = false;

        //Get the next game in the queue
        game_data_current = game_data[0];

        //Get the first state of this new game
        var first = game_data_current[0];

        wave_current = first.wave;
        waveText.text = "Wave " + first.wave;

        mainText.visible = false;
        introText.visible = false;
        inGame = true;

        //Make Players
        for (var i = 0; i < first.players.length; i++) {
          create_player(first.players[i]);
        }

        //Make the core
        create_core(first.core);

        if (test) {
          toggleClasses("testBtn", ["greyOut", "noEvents"], false);
        }

        draw();
        ticker.start();
      }

      function create_health_bar() {
        var red = new PIXI.Graphics();
        var green = new PIXI.Graphics();
        var width = HEALTHBARWIDTH;
        var height = 4;
        var radius = 2;
        red.beginFill(0xff0000);
        red.lineStyle(2, 0x0, 0);
        green.beginFill(0x00ff00);
        red.drawRoundedRect(0, 0, width, height, radius);
        green.drawRoundedRect(0, 0, width, height, radius);

        var health = new PIXI.Container();
        health.addChildAt(red, 0);
        health.addChildAt(green, 1);
        return health;
      }

      function create_entity_triangle(data) {
        var container = new PIXI.Container();
        var sprite = create_triangle({x:0, y:0}, data.vel, data.size, data.color);
        container.addChild(sprite);

        var health = create_health_bar();
        health.y = data.size + 2;
        health.x = -health.width/2;
        container.addChild(health);

        container.position = data.pos;
        entity_layer.addChildAt(container, 0);

        var emitter = new PIXI.particles.Emitter(
                particle_layer,
                [sprite.generateCanvasTexture()],
                {
                        alpha: {
                                start: 1,
                                end: 1
                        },
                        scale: {
                                start: 1,
                                end: 0.2
                        },
                        speed: {
                                start: 0,
                                end: 0
                        },
                        lifetime: {
                                min: 1,
                                max: 1
                        },
                        frequency: 0.001,
                        emitterLifetime: -1,
                        maxParticles: 100,
                        pos: {
                                x: container.x,
                                y: container.y
                        },
                        addAtBack: false,
                        spawnType: "point"
                }
        );
        emitter.emit = true;

        return {
          container: container,
          sprite: sprite,
          emitter: emitter,
          health: health,
        };
      }

      function create_player(data) {
        var player = create_entity_triangle(data);
        playerDict[data.tag] = player;

        var ammo = new PIXI.Text(data.ammo.toString(),
                                        { fontFamily: "Arial",
                                          fontSize: 12,
                                          fill: "black",
                                          align: "center"});

        var attack_area = new PIXI.Graphics();
        attack_area.lineStyle(4, data.color);
        attack_area.drawCircle(0, 0, data.range_visible);
        particle_layer.addChildAt(attack_area, 0);
        attack_area.position = data.pos;
        attack_area.alpha = 0.15;
        //attack_area.blendMode = PIXI.BLEND_MODES.EXCLUSION;

        var visible_area = new PIXI.Graphics();
        visible_area.beginFill(data.color);
        visible_area.drawCircle(0, 0, data.range_attackable);
        particle_layer.addChildAt(visible_area, 0);
        visible_area.position = data.pos;
        visible_area.alpha = 0.15;
        //visible_area.blendMode = PIXI.BLEND_MODES.LIGHTEN;

        //Glow
        player.container.filters = [new PIXI.filters.GlowFilter(6, 0.8, 0, data.color, 1)];

        ammo.anchor.x = 0.5;
        ammo.anchor.y = -1.5;
        ammo.y = -data.size/2 - 2;

        var name = new PIXI.Text(data.name,
                                        { fontFamily:"Arial",
                                          fontSize:"16",
                                          fill: "black"});
        name.anchor.x = 0.5;
        name.anchor.y = 2;

        player.container.addChild(ammo);
        player.container.addChild(name);
        player.ammo = ammo;
        player.name = name;
        particle_layer.addChildAt(visible_area, 0);
        particle_layer.addChildAt(attack_area, 0);
        player.visible_area = visible_area;
        player.attack_area = attack_area;
        player.message = null;
      }

      function create_core(data) {
        var container = new PIXI.Container();
        var sprite = new PIXI.Graphics();

        container.addChild(sprite);

        var health = create_health_bar();
        health.y = data.size + 2;
        health.x = -HEALTHBARWIDTH/2;
        container.addChild(health);

        container.position = data.pos;
        entity_layer.addChildAt(container, 0);

        var texture = new PIXI.Graphics();
        texture.beginFill(PIXI.utils.rgb2hex([0,1,1]));
        texture.drawCircle(0, 0, data.size);

        var emitter = new PIXI.particles.Emitter(
                particle_layer,
                [texture.generateCanvasTexture()],
                {
                        scale: {
                          start: 0.5,
                          end: 0.2
                        },
                        speed: {
                          start: 40,
                          end: 0
                        },
                        lifetime: {
                          min: 0.2,
                          max: 0.8
                        },
                        color: {
                          start: "#00ffff",
                          end: "#00ffff"
                        },
                        startRotation: {
                          min: 0,
                          max: 360
                        },
                        frequency: 0.01,
                        emitterLifetime: -1,
                        maxParticles: 100,
                        pos: {
                          x: container.x,
                          y: container.y
                        },
                        addAtBack: false,
                        spawnType: "point",
                }
        );

        core = {
          container: container,
          emitter: emitter,
          sprite: sprite,
          health: health
        };
      }

      function create_attack(from, to) {
        var graphics = new PIXI.Graphics();
        var width = 2;
        graphics.lineStyle(2, PIXI.utils.rgb2hex([1, 0, 0]));
        graphics.moveTo(from.x, from.y);
        graphics.lineTo(to.x, to.y);
        particle_layer.addChild(graphics);
        attacks.push({sprite: graphics,
                      timer: 0});
      }

      function create_enemy(data) {
        data.color = ENEMYC;
        enemies[data.tag] = create_entity_triangle(data);
      }

      function create_pickup(data) {
        var container = new PIXI.Container();
        var sprite = new PIXI.Graphics();
        var size = data.size;

        var color = PIXI.utils.rgb2hex([0.3, 0.7, 0.1]);
        sprite.lineStyle(1, 0x0, 1);

        var text = 'Ammo';
        if (data.type == 'health') {
          text = 'Health';
          sprite.beginFill(PIXI.utils.rgb2hex([1,1,1]));
          sprite.drawRect(0, 0, size, size);
          sprite.lineStyle(0);
          sprite.beginFill(PIXI.utils.rgb2hex([0.8, 0, 0]));
          sprite.drawRect(size/3, 0, size/3, size);
          sprite.drawRect(0, size/3, size, size/3);
        } else {
          sprite.beginFill(color);
          sprite.drawRect(0, 0, size, size);
        }
        sprite.pivot.x = size/2;
        sprite.pivot.y = size/2;

        container.addChild(sprite);

        var label = new PIXI.Text(data.value.toString(),
                                              { fontFamily:"Arial",
                                                fontSize:"12",
                                                fill: color,
                                                align: "center" });
        label.anchor.y = 0;
        label.anchor.x = 0.5;
        label.y = size;
        //container.addChild(label);

        var title = new PIXI.Text(text,
                                        { fontFamily:"Arial",
                                          fontSize:"14",
                                          fill: color,
                                          align: "center" });
        title.anchor.y = 1;
        title.anchor.x = 0.5;
        title.y = -size;
        //container.addChild(title);

        container.position = data.pos;
        entity_layer.addChildAt(container, 0);

        pickups[data.tag] = {
          container: container,
          sprite: sprite,
          label: label
        };
      }

      function create_message(string) {
        var font_size = 16;
        var padding = 4;
        var text_length = 40;
        var elipses = "...";
        if (string.length > text_length) {
          string = string.substring(0, text_length-3) + "...";
        }

        var text = new PIXI.Text(string,
                                        { fontFamily:"Arial",
                                          fontSize: font_size,
                                          fill: "black",
                                          align: "left"});
        text.position.x = padding;
        text.position.y = padding;

        var bubble = new PIXI.Graphics();
        bubble.lineStyle(1, "black", 0.5);
        bubble.beginFill(PIXI.utils.rgb2hex([1,1,1]));
        bubble.drawRoundedRect(0, 0, text.width + padding * 2,
                                      text.height + padding * 2, padding);

        bubble.addChild(text);
        return bubble;
      }

      function player_say(data, string) {
        var p = playerDict[data.tag];
        if (p.message) {
          p.container.removeChild(p.message.container);
          p.message = null;
        }

        var msg = create_message(string);
        msg.x = -msg.width/2;
        msg.y = -msg.height - data.size - 20;
        p.container.addChildAt(msg);
        p.message = {container: msg, timer: MSG_DISPLAY_TIME};
      }

      function clearup_pickup(tag) {
        var p = pickups[tag];

        var emitter = new PIXI.particles.Emitter(
                particle_layer,
                [p.sprite.generateCanvasTexture()],
                {
                        color: {
                          start: "0xffffff",
                          end: "0xffffff"
                        },
                        alpha: {
                                start: 1,
                                end: 0.9
                        },
                        scale: {
                                start: 0.6,
                                end: 0.2
                        },
                        speed: {
                                start: 200,
                                end: 0
                        },
                        lifetime: {
                                min: 0.2,
                                max: 0.2
                        },
                        startRotation: {
                          min: 0,
                          max: 360
                        },
                        frequency: 0.005,
                        emitterLifetime: 0.01,
                        maxParticles: 7,
                        pos: {
                                x: p.container.x,
                                y: p.container.y
                        },
                        addAtBack: false,
                        spawnType: "burst",
                        particlesPerWave: 8,
                        particleSpacing: 45,
                        angleStart: 0
                }
        );

        entity_layer.removeChild(p.container);
        emitter.playOnceAndDestroy();
        delete pickups[tag];
      }

      function clearup_player(tag) {
        var p = playerDict[tag];
        var emitter = new PIXI.particles.Emitter(
                particle_layer,
                [p.sprite.generateCanvasTexture()],
                {
                        color: {
                          start: "0xffffff",
                          end: "0xffffff"
                        },
                        alpha: {
                                start: 0.9,
                                end: 0.8
                        },
                        scale: {
                                start: 0.7,
                                end: 0.5
                        },
                        speed: {
                                start: 150,
                                end: 0
                        },
                        lifetime: {
                                min: 0.4,
                                max: 0.2
                        },
                        startRotation: {
                          min: 0,
                          max: 360
                        },
                        frequency: 0.0001,
                        emitterLifetime: 0.01,
                        maxParticles: 7,
                        pos: {
                                x: p.container.x,
                                y: p.container.y
                        },
                        addAtBack: false,
                        spawnType: "point",
                }
        );
        entity_layer.removeChild(p.container);
        emitter.playOnceAndDestroy();
        delete playerDict[tag];
      }

      function clearup_enemy(tag) {
        //Particles!
        var e = enemies[tag];

        var emitter = new PIXI.particles.Emitter(
                particle_layer,
                [e.sprite.generateCanvasTexture()],
                {
                        alpha: {
                                start: 0.9,
                                end: 0.8
                        },
                        scale: {
                                start: 0.7,
                                end: 0.5
                        },
                        speed: {
                                start: 150,
                                end: 0
                        },
                        lifetime: {
                                min: 0.4,
                                max: 0.2
                        },
                        startRotation: {
                          min: 0,
                          max: 360
                        },
                        frequency: 0.0001,
                        emitterLifetime: 0.01,
                        maxParticles: 7,
                        pos: {
                                x: e.container.x,
                                y: e.container.y
                        },
                        addAtBack: false,
                        spawnType: "point",
                }
        );

        entity_layer.removeChild(e.container);
        emitter.playOnceAndDestroy();
        delete enemies[tag];
      }

      function clearup_core() {
        var emitter = new PIXI.particles.Emitter(
                particle_layer,
                [core.sprite.generateCanvasTexture()],
                {
                        alpha: {
                                start: 1,
                                end: 0.8
                        },
                        scale: {
                                start: 1.2,
                                end: 0.5
                        },
                        color: {
                                start: "ff0000",
                                end: "0f0202"
                        },
                        speed: {
                                start: 400,
                                end: 0
                        },
                        lifetime: {
                                min: 1,
                                max: 0.5
                        },
                        startRotation: {
                          min: 0,
                          max: 360
                        },
                        frequency: 0.0001,
                        emitterLifetime: 0.01,
                        maxParticles: 400,
                        pos: {
                                x: core.position.x,
                                y: core.position.y
                        },
                        addAtBack: false,
                        spawnType: "point",
                }
        );
        core.container.visible = false;
        emitter.playOnceAndDestroy();
      }

      //Update player details/scripts
      function updateRoom(data) {
        var room = JSON.parse(data);

        //Check if player has joined
        for (var i = 0; i < room.players.length; i++) {
          if (room.players[i].id == playerID) {
            tryAddPlayer(room.players[i]);
            break;
          }
        }

        //Check if players have joined
        for (var j = 0; j < room.players.length; j++) {
          tryAddPlayer(room.players[j]);
          if (room.players[j].id != playerID) {
            var s = getPlayer(room.players[j].id);
            players[s].script = room.players[j].script;
            players[s].name = room.players[j].name;
            if (currentTab == s) {
              editor.setValue(players[s].script, -1);
            }
          }
        }

        //Check if players have left
        if (players.length > room.players.length) {
          for (var i = 0; i < players.length; i++) {
            var present = false;

            for (var j = 0; j < room.players.length; j++) {
              if (players[i].id == room.players[j].id) {
                present = true;
              }
            }

            if (!present) {
              players.splice(i, 1);

              var tabs = document.getElementsByClassName("tabBtn");
              var tabLis = document.getElementsByClassName("tabLi");
              for (var k = 1; k < MAXPLAYERS; k++) {
                if (k >= players.length) {
                  tabs[k].innerHTML = "";
                  tabLis[k].classList.add("noDisplay");
                  tabs[k].classList.remove("ready");
                  tabs[k].classList.remove("activeReady")
                  if (k == currentTab) {
                    setEditorTab(0);
                  }
                } else {
                  tabs[k].innerHTML = players[k].name;
                }
              }

              i--;
            }
          }
        }

        //Check if players are ready
        for (var i = 0; i < room.players.length; i++) {
          var j = getPlayer(room.players[i].id);
          var t = document.getElementById("tab" + j);
          if (room.players[i].status === 'ready') {
            if (t.classList.contains("active")) {
              t.classList.add("activeReady");
            } else {
              t.classList.add("ready");
            }
          } else {
            t.classList.remove("ready");
            t.classList.remove("activeReady");
          }
        }
      }

      function getPlayer(id) {
        for (var i = 0; i < players.length; i++) {
          if (players[i].id == id) {
            return i;
          }
        }
        return -1;
      }

      //If a player isn't already stored then store their details
      function tryAddPlayer(player) {
        if (havePlayer(player.id)) {
          return false;
        }
        players.push({"script":player.script, "id":player.id, "name":player.name});
        var t = document.getElementById("tabLi" + (players.length - 1));
        var tb = document.getElementById("tab" + (players.length - 1));
        var tc = document.getElementById("tabClr" + (players.length - 1));
        tc.style.backgroundColor = '#' + player.color;
        tb.innerHTML = player.name.substring(0, TAB_NAME_CHAR_LIMIT);
        t.classList.remove("noDisplay");
        return true;
      }

      //Function to tell if a player id is already present in the room
      function havePlayer(id) {
        for (var i = 0; i < players.length; i++) {
          if (players[i].id == id) {
            return true;
          }
        }
        return false;
      }

      function draw() {
        renderer.render(stage);
      }

      //Tell server that the client is leaving
      function exitGame(e) {
        socket.emit(EVENTS.LEFT, {});
        socket.disconnect();
      }

      function submitCode() {
        if (editor.getValue() !== players[0].script && currentTab == 0) {
          players[0].script = editor.getValue();
        }
        socket.emit(EVENTS.SUBMIT, players[0].script);
      }

      function game_test() {
        game_terminate();
        socket.emit(EVENTS.TEST, editor.getValue());
        toggleClasses("testBtn", ["active", "noEvents"], true);
        toggleClasses("readyBtn", ["greyOut", "noEvents"], true);
        test = true;
      }

      function clear_current_game_data() {
        timer = 0;
        timer_end = 0;
        playerDict = {};
        enemies = {};
        pickups = {};
        core = null;
        game_data_current = null;
        inGame = false;
        for (var i = 0; i < game_layer.children.length; i++) {
          game_layer.getChildAt(i).removeChildren();
        }
      }

      //Function to leave the game
      function leaveGame() {
        submitCode();
        window.location.href = "{{ url_for('main.home') }}";
      }

      //Ready up
      function readyUp() {
        var btnText;
        if (!ready) {
          submitCode();
          btnText = "Cancel"
          socket.emit(EVENTS.PLAY, {});
          test = false;
        } else {
          btnText = "Start Game";
          socket.emit(EVENTS.CANCEL, {});
        }
        document.getElementById("readyBtn").innerHTML = btnText;
        ready = !ready;
        toggleClasses("readyBtn", ["active"], ready);
        toggleClasses("testBtn", ["greyOut", "noEvents"], ready);
      }

      //Initialise gameCanvas - initialise stage, add shape drawer
      function initCanvas() {
        ticker = new PIXI.ticker.Ticker();
        ticker.add(game_loop);

        var canvas = document.getElementById("gameCanvas");
        renderer = PIXI.autoDetectRenderer(800, 600, {view: canvas, antialias: true});
        stage = new PIXI.Container();
        renderer.backgroundColor = 0xffffff;

        hud_layer = new PIXI.Container();

        game_layer = new PIXI.Container();
        entity_layer = new PIXI.Container();
        particle_layer = new PIXI.Container();

        background_layer = new PIXI.Container();

        game_layer.addChild(particle_layer);
        game_layer.addChild(entity_layer);
        game_layer.width = renderer.width;
        game_layer.height = renderer.height;

        stage.addChild(background_layer);
        stage.addChild(game_layer);
        stage.addChild(hud_layer);


        textStyle = new PIXI.TextStyle({
          fontFamily: 'Arial',
          fontSize: 36,
          //fontWeight: 'bold',
          fill: ['#ffffff'], // gradient
          align: 'center',
          strokeThickness: 2,
          dropShadow: true,
          dropShadowColor: '#000000',
          dropShadowBlur: 2,
          dropShadowAlpha: 0.8,
          dropShadowAngle: Math.PI / 6,
          dropShadowDistance: 0,
        });

        textStyle.fontSize = 20;
        fpsText = new PIXI.Text("", textStyle);
        fpsText.x = 10;
        fpsText.y = 10;
        hud_layer.addChild(fpsText);

        waveText = new PIXI.Text("Wave 1", textStyle);
        waveText.anchor.x = 1;
        waveText.x = renderer.width - 10;
        waveText.y =  10;
        hud_layer.addChild(waveText);

        fade = new PIXI.Graphics();
        fade.beginFill(PIXI.utils.rgb2hex([1, 1, 1]));
        fade.drawRect(0, 0, renderer.width, renderer.height);
        fade.blendMode = PIXI.BLEND_MODES.MULTIPLY;
        hud_layer.addChildAt(fade, 0);
        fade.alpha = 0;
        fade.visible = false;

        draw_grid();

        startWaiting();
        draw();
      }

      function game_loop() {
        delta = ticker.elapsedMS/1000;
        timer += delta;
        timer_end -= delta;
        fpsText.text = (Math.round(ticker.FPS * 100) / 100).toString() + " FPS";
        if (inGame) {
          if (game_data_current.length > 0) {
            last_state = game_data_current[0]
            process_state(last_state, delta);
            game_data_current.splice(0, 1);
          } else {
            //Waiting for more data...
            console.log("Waiting for data...")
          }
        } else if (timer_end > 0) {
          var param = Math.min(timer_end / TIME_AFTER_END, 1);
          fade.alpha = 0.5 * (1 - param);
          process_state_end(last_state, delta);
        } else {
          ticker.stop();
          if (game_data.length > 0) {
            game_start();
          }
        }
      }

      //Clear shape drawer, then draw game state to gameCanvas
      function process_state(state, delta) {
        //Process events
        //Create & delete entities

        var events = state.events;
        for (var i = 0; i < events.length; i++) {
          var e = events[i];
          var body = e.body;
          switch (e.name) {
            case "Enemy_Spawn":
              create_enemy(body);
              break;
            case "Enemy_Death":
              clearup_enemy(body.tag);
              break;
            case "Player_Death":
              clearup_player(body.tag);
              break;
            case "Pickup_Spawn":
              create_pickup(body);
              break;
            case "Pickup_Used":
              clearup_pickup(body.tag);
              break;
            case "Game_End":
              // console.log('RIP game');
              game_end(body);
              break;
            case "Attack":
              create_attack(body[0].pos, body[1].pos);
              break;
            case "Print":
                if (body[1].player_id == playerID) {
                    printToConsole("[PRINT]: " + body[0], "#F0F");
                }
              break;
            case "Error":
                if (body[1].player_id == playerID) {
                    printToConsole("[ERR]: " + body[0], "#F00");
                }
              break;
            case "Message_Sent":
              //printToConsole(body.source.name + " sent message: " + body.string, "#ABC");
              break;
            case "Chat_Bubble":
              player_say(body.source, body.string);
              break;
            default:
              //console.log("Unknown event: " + e.name);
          }
        }

        //Updates
        draw_enemies(state.enemies, delta);
        draw_pickups(state.pickups, delta);
        draw_players(state.players, delta);
        update_core(state.core, delta);

        //Effects
        draw_attacks(delta);

        draw();
      }

      function process_state_end(state, delta) {
        //Updates
        //draw_enemies(state.enemies, delta);
        //draw_pickups(state.pickups, delta);
        //draw_players(state.players, delta);
        update_core(state.core, delta);

        //Effects
        draw_attacks(delta);

        draw();
      }

      function game_end(result) {
        timer_end = TIME_AFTER_END;
        inGame = false;
        if (result != "Win" || test) {
          endGame();
        }
        test=false;
        fade.visible = true;
        fade.alpha = 0;
        var text
        switch (result) {
          case "Lose_Core":
            text = "Core Destroyed";
            clearup_core();
            fade.tint = PIXI.utils.rgb2hex([1, 0, 0]);
            break;
          case "Lose_Players":
            if (players.length > 1) {
              text = "Everyone Died"
            } else {
              text = "You Died"
            }
            fade.tint = PIXI.utils.rgb2hex([1, 0, 0]);
            break;
          case "Lose_Timeout":
            text = "Time up!"
            fade.tint = PIXI.utils.rgb2hex([1, 0, 0]);
            break;
          case "Win":
            text = "Wave " + wave_current + " complete!"
            fade.tint = PIXI.utils.rgb2hex([0, 1, 0]);
            break;
          default:
            text = "What happened?"
            console.log("Unknown ending: " + result);
        }

        mainText.text = text;
        mainText.visible = true;

        game_data.splice(0, 1);
      }

      function endGame() {
        toggleClasses("testBtn", ["greyOut", "noEvents", "active"], false);
        toggleClasses("readyBtn", ["greyOut", "noEvents", "active"], false);
        document.getElementById("readyBtn").innerHTML = "Start Game"
        if (!test){
          for (var i = 0; i < players.length; i++) {
            toggleClasses("tab" + i, ["ready", "activeReady"], false);
          }
        }
        while (trophyQueue.length > 0) {
          printToConsole("[TROPHY]: " + trophyQueue[0], "#c99c20");
          trophyQueue.splice(0, 1);
        }
        ready = false;
      }

      function game_terminate() {
        ticker.stop();
        clear_current_game_data();
        game_data.splice(0,1);
      }

      function vector_to_rotation(dir) {
        return Math.atan2(dir.y, dir.x) + Math.PI/6;
      }

      function draw_attacks(delta) {
        for (var i = 0; i < attacks.length; i++) {
          var a = attacks[i];
          a.timer = a.timer + delta;
          if (a.timer >= attack_fade) {
            particle_layer.removeChild(a.sprite);
            attacks.splice(i, 1);
            i--;
          } else {
            a.sprite.alpha = 1 - a.timer/attack_fade;
          }
        }
      }

      function interpolate_rgb(from, to, alpha) {
        var result = [];
        for (var i = 0; i < from.length; i++) {
          result[i] = from[i] + (to[i] - from[i]) * alpha;
        }
        return result;
      }

      function update_core(data, delta) {
        var param = data.health/data.healthMax;
        var from = [0, 1, 1];
        var to = [1, 0, 0];
        var color = interpolate_rgb(from, to, 1 - param);
        var color255 = color.map(function(x) {return x * 255;});

        core.sprite.clear();
        core.sprite.lineStyle(2, PIXI.utils.rgb2hex([1,1,1]), 1);
        core.sprite.beginFill(PIXI.utils.rgb2hex(color));
        core.sprite.drawCircle(0, 0, data.size);

        core.position = data.pos;
        core.health.getChildAt(1).scale.x = param;
        core.emitter.update(delta);
      }

      //Create equilateral triangle facing DIR
      function create_triangle(pos, dir, radius, color) {
        var shape = new PIXI.Graphics();

        var base = 2 * radius * Math.cos(Math.PI/6);
        var height = radius * (1 +  Math.sin(Math.PI/6));

        shape.beginFill(color);
        shape.drawPolygon([0, 0, base, 0, base/2, height, 0, 0]);
        shape.endFill();

        shape.x = pos.x;
        shape.y = pos.y;
        shape.pivot.x = 0.5 * base;
        shape.pivot.y = 1/3 * height;

        return shape;
      }

      function update_entity(entity, data, delta) {
        entity.container.position = data.pos;
        if (data.vel.x != 0 || data.vel.y != 0) {
          entity.sprite.rotation = vector_to_rotation(data.vel);
          entity.health.getChildAt(1).scale.x = data.health/data.healthMax;
          entity.emitter.updateOwnerPos(data.pos);
          entity.emitter.update(delta);
        }
      }

      // Draw every object in a list the same color
      function draw_enemies(list, delta) {
        for (var i = 0; i < list.length; i++) {
          update_entity(enemies[list[i].tag], list[i], delta);
        }
      }

      // Draw every player and update name locations
      function draw_players(list, delta) {
        for (var i = 0; i < list.length; i++) {
          var data = list[i];
          var player = playerDict[data.tag];
          update_entity(player, data, delta);
          player.ammo.text = data.ammo.toString();
          player.visible_area.position = data.pos;
          player.attack_area.position = data.pos;
          if (player.message) {
            player.message.timer -= delta;
            if (player.message.timer <= 0) {
              player.container.removeChild(player.message.container);
              player.message = null;
            }
          }
        }
      }

      function draw_pickups(list, delta) {
        for (var i = 0; i < list.length; i++) {
          var p = pickups[list[i].tag];
          p.sprite.rotation = (timer * 5) % 20;
        }
      }

      function setEditorTab(tabi) {
        var oldt = document.getElementById("tab" + currentTab);
        oldt.classList.remove("active");
        if (oldt.classList.contains("activeReady")) {
          oldt.classList.remove("activeReady");
          oldt.classList.add("ready");
        }
        var newt = document.getElementById("tab" + tabi);
        newt.classList.add("active");
        if (newt.classList.contains("ready")) {
          newt.classList.remove("ready");
          newt.classList.add("activeReady");
        }
        if (currentTab == 0) {
          players[0].script = editor.getValue();
        }
        currentTab = tabi;
        editor.setValue(players[tabi].script, -1);
        editor.setReadOnly(tabi != 0);
        editor.focus();
      }

      //Initialise the editor
      function initEditor() {
        editor = ace.edit("editor");
        editor.$blockScrolling = Infinity;
        editor.getSession().setMode("ace/mode/python");
        editor.getSession().setUseWrapMode(true);
        editor.getSession().setTabSize(4);
        editor.getSession().setUseSoftTabs(true);
        editor.setValue(`{{user.script|safe}}`, -1);
      }

      //Prints to the on screen console
      function printToConsole(data, color){
        printTo(true, data, color);
      }

      function printToChat(data, color){
        printTo(false, data, color);
      }

      function printTo(console, data, color) {
        var c;
        if (console) {
          c = document.getElementById("console");
        } else {
          c = document.getElementById("chat");
        }
        var s = document.createElement("span");
        s.textContent = data + "\n";
        s.classList.add("console");
        s.style.color = color;
        var scrollAtBottom = c.scrollHeight - c.clientHeight <= c.scrollTop + 1;
        c.appendChild(s);
        if (scrollAtBottom) {
          c.scrollTop = c.scrollHeight;
        }

      }

      function toggleChatConsole(console) {
        var cons = document.getElementById("console");
        cons.classList.toggle("noDisplay");
        var chat = document.getElementById("chatContainer");
        chat.classList.toggle("noDisplay");
        toggleClasses("consoleBtn", ["active", "noEvents"], console);
        toggleClasses("chatBtn", ["active", "noEvents"], !console);
      }

      function handleChatIn(data) {
        var msg = JSON.parse(data);
        printToChat("[" + msg.name + "]: " + msg.body, msg.color);
      }

      function sendChatMessage(event) {
        if (event.keyCode == 13) {
          var chat = document.getElementById("chat");
          var input = document.getElementById("inputChat");
          socket.emit(EVENTS.CHAT, input.value);
          input.value = "";
        }
      }

      function toggleClasses(id, classes, add) {
        var e = document.getElementById(id).classList;
        for (var i = 0; i < classes.length; i++) {
          if (add) {
            e.add(classes[i]);
          } else {
            e.remove(classes[i]);
          }
        }
      }

    </script>
{% endblock %}
{% block body %}
    {{ suddendev_logged_in_header_game(user.picture, user.name, user.email) }}

    <div class="container-fluid">
      <div class="row">
        <div class="col mainCol gameCol">
          <div class="row topRow noMargin justify-content-end">
            <div class="key">
              <span class="key">Your room key is <code class="inlineBlock">{{ game_id }}</code></span>
            </div>
          </div>
          <div class="row noMargin">
            <div id="gameDiv">
              <canvas id="gameCanvas" class="block" width="800px" height="600px"></canvas>
            </div>
          </div>
          <div class="row btnRow">
            <div class="col noPadding">
              <div class="btn-toolbar justify-content-between">
                <div class="btn-group">
                  <button class="btn btn-outline-danger" onclick="leaveGame()">Leave Game</button>
                </div>
                <div class="btn-group">
                  <button id="testBtn" class="btn btn-outline-info" onclick="game_test()">Test Code</button>
                  <button id="readyBtn" class="btn btn-outline-success" onclick="readyUp()">Start Game</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col mainCol">
          <div class="row topRow noMargin">
            <ul id="edit-tab" class="nav nav-tabs fullWidth">
               <li id="tabLi0" class="nav-item active tabLi" onClick="setEditorTab(0)">
                 <div class="fullWidth fullHeight" style="display: flex; flex-direction: column; align-content: stretch">
                   <button id="tab0" class="nav-link tabBtn active" onClick="setEditorTab(0)" style="flex: 0 0 auto">Player 1</button>
                   <div id="tabClr0" style="flex: 1 1 auto; background-color: #00f;"></div>
                 </div>
                </li>
                <li id="tabLi1" class="nav-item noDisplay tabLi">
                 <div class="fullWidth fullHeight" style="display: flex; flex-direction: column; align-content: stretch">
                  <button id="tab1" class="nav-link tabBtn" onclick="setEditorTab(1)"></button>
                   <div id="tabClr1" style="flex: 1 1 auto; background-color: #00f;"></div>
                 </div>
                </li>
                <li id="tabLi2" class="nav-item noDisplay tabLi">
                 <div class="fullWidth fullHeight" style="display: flex; flex-direction: column; align-content: stretch">
                  <button id="tab2" class="nav-link tabBtn" onclick="setEditorTab(2)"></button>
                   <div id="tabClr2" style="flex: 1 1 auto; background-color: #00f;"></div>
                 </div>
                </li>
                <li id="tabLi3" class="nav-item noDisplay tabLi">
                 <div class="fullWidth fullHeight" style="display: flex; flex-direction: column; align-content: stretch">
                  <button id="tab3" class="nav-link tabBtn" onclick="setEditorTab(3)"></button>
                   <div id="tabClr3" style="flex: 1 1 auto; background-color: #00f;"></div>
                 </div>
                </li>
            </ul>
          </div>
          <div class="row fullWidth noMargin midRow">
            <div id="editor" class="greyBorder fullWidth"></div>
            <div class="fullWidth consoleContainer">
              <div class="card fullWidth fullHeight">
                <div id="console" class="card-block"></div>
                <div id="chatContainer" class="card-block noDisplay" style="">
                  <div id="chat"></div>
                  <div class="greyBorder chatIn">
                    <input id="inputChat" class="fullWidth chatIn" onkeydown="sendChatMessage(event)"></input>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="row btnRow">
            <div class="col noPadding">
              <div class="btn-toolbar justify-content-between">
                <div class="btn-group">
                  <button id="consoleBtn" class="btn btn-outline-warning active noEvents" onclick="toggleChatConsole(true);">Console</button>
                  <button id="chatBtn" class="btn btn-outline-warning" onclick="toggleChatConsole(false);">Chat</button>
                </div>
                <div class="btn-group">
                  <button class="btn btn-outline-info" onclick="submitCode()">Commit</button>
                  <a href="{{ url_for('.docs') }}" class="btn btn-outline-info" role="button" target="_blank">Help!</a>
                  <!-- Modal Button: <button class="btn btn-outline-info" data-toggle="modal" data-target="#docModal">Show me the docs!</button> !-->
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="docModal" class="modal fade" role="dialog">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-body">
            <div id="getting-started" class="card m-3">
              <div class="card-header card-inverse card-success">
                <!-- Cheat Sheet Header !-->
                <h4 style="color:#fff"> Cheat Sheet </h4>
              </div>
              <div class="card-block">
                <!-- Cheat Sheet Content !-->
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <a href="{{ url_for('.docs') }}" class="btn btn-outline-info" role="button" target="_blank">Open the Full Docs</a>
          </div>
        </div>
      </div>
    </div>
  <script>initCanvas();initSocket();initEditor();</script>
{% endblock %}
