{% extends "base.html" %}
{% from 'macros.html' import suddendev_header %}
{% block body %}

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
<link rel="stylesheet" type="text/css" href="{{url_for('static', filename='style_docs.css')}}">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>
    hljs.initHighlightingOnLoad();
    </script>

  {{ suddendev_header() }}
  <div class="container">
    <center>
      <h2>A co-op survival game where your code plays for you.</h2><br>
    </center>
  <div id="toc" class="card m-3">
      <div class="card-header card-inverse card-success">
        <h4> Table of Contents </h4>
      </div>
  <div class="card-block">
      <ul>
          <li><a href="#getting-started">Getting Started</a><br></li>
          <li><a href="#gameplay-basics">Gameplay Basics</a><br></li>
          <li><a href="#scripting-basics">Scripting Tutorial</a><br></li>
          <li><a href="#tips-and-tricks">Tips and Tricks</a><br></li>
          <li><a href="#scripting-reference">Scripting Reference</a><br></li>

      </ul>
  </div>
  </div>

  <div id="getting-started" class="card m-3">
      <div class="card-header card-inverse card-success">
        <h4> Getting Started </h4>
      </div>

      <div class="card-block">
	      <ol>
            <li>Protect the <b>core</b> (the blue circle)</li>
            <li>For each wave, at least one player needs to survive</li>
            <li>Don't die and don't run out of ammo</li>
	      </ol>

	      <p>Keep this page open for reference.</p>
	      <p>Head to your <a href={{ url_for('.home') }}>home</a>, create a game, invite friends and try to survive as many waves as possible.</p>
	    </div>
          </div>
    <div id="gameplay-basics" class="card m-3">
      <div class="card-header card-inverse card-success">
    <h4> Gameplay Basics </h4>
    </div>
      <div class="card-block">
	      <p>You control a <b>fierce</b> little triangle. It can:</p>
	      <ol>
		<li>Move (obviously)</li>
		<li>See what's nearby</li>
		<li>Attack enemy triangles</li>
		<li>Message other little triangles (your team)</li>
	      </ol>
	      <p>Your triangle has finite health and ammo, but can replenish both by grabbing pickups.</p>
	      <p>You can form a team of triangles to defend the circle from incoming waves.</p>
	      <p>At the end of each wave, you are reborn with full health, ready to fight again.
	      The ultimate aim is to clear as many waves as possible. Each wave is harder than the last. </p>

	      <p>You'll need as much help as possible (up to 3 team-mates), and some clever strategies to succeed.
	      Give it your best shot, and have fun!</p>
          </div>
    </div>
    <div id="scripting-basics" class="card m-3">
      <div class="card-header card-inverse card-success">
    <h4> Scripting Tutorial </h4>
    </div>
      <div class="card-block">
            This is a game about writing scripts. Your script will tell your triangle what to do and where to go.
            You'll be writing in <b>Python</b>, a popular scripting language. There are plenty of resources online, as well as examples below, to help you get started.<br><br>

            <h4> The Basics </h4><br>
            In your script, you only need to define one function:<br>
            <div class="card card-outline-danger">
            <pre><code class="python code-block">def update(player, delta):
  #insert behaviour here</code></pre></div>
            <br>
            This function will be called 30 times per second when the game is running. What you write in it will determine how your triangle behaves.
            The <code>player</code> object is a reference to your character, and <code>delta</code> is the time, in seconds, since the last frame. This will be really handy later on.

            To move around, you can set the <code>vel</code> property of your player. For example, move to the right:<br>
            <div class="card card-outline-danger">
            <pre><code class="python code-block">def update(player, delta):
  player.vel = Vector(10, 0)</code></pre></div>
            <br>
            The unit of distance in this game is the pixel, so a speed of 10 means 10 pixels per second. We've provided some built-in functions to help you with handling vectors, distance calculations, and movement.
            
            <div class="card card-outline-danger">
            <pre><code class="python code-block">move_to(pos) #set velocity to move at full speed towards 'pos'
distance_to(pos) #returns the distance from your player to 'pos'
shoot(entity)</code></pre></div>
            <br>
            Everything in the game is an <b>Entity</b> - pickups, players, enemies, and the core. Every entity has a attributes that you can read such as position, velocity and health. So if you have a reference to a pickup that you want to grab, call<br><br>

            <code>move_to(somePickup.pos)</code> to move to its position, or you can pass in the object reference itself<br>
            <code>move_to(somePickup)</code>, to achieve the same thing.<br><br>

            to make your character move towards the pickup. This function just sets the velocity of your character to be towards the pickup.

            also moves your bot towards the pickup. Similarly, you can use<br><br>
            <div class="card card-outline-danger">
            <pre><code class="python code-block"> 
move_from(entity)</code></pre></div><br>
            which makes your character move away from the entity. All of these functions optionally accept speed as a parameter, so calling<br><br>
            <code>move_to(pickup, 80)</code><br><br>
            makes your character go towards the pickup with speed 80.<br><br>
            
            <h4>How do you get hold of these entities?</h4><br>
            You have access to these lists, which you can freely use in your code:<br>
            <code>enemies_visible</code>, which contains all the enemy entities that your character can see<br>
            <code>enemies_attackable</code>, which contains all the enemy entities that your character can attack<br>
            <code>pickups_visible</code>, which contrains all the pickups that your character can see<br><br>

            You can access and iterate through these lists just like in ordinary Python. Often you might want to find the nearest object in the list, for example, the nearest visible enemy. You might want to make use of these functions:<br><br>

            <div class="card card-outline-danger">
            <pre><code class="python code-block"> 
get_nearest_enemy()
get_nearest_attackable_enemy()
get_nearest_pickup()</code></pre></div><br> 
            You can also pass in a <code>PickupType</code> to <code>get_nearest_pickup()</code> to specify which pickup you're interested in, i.e.<br><br>

            <div class="card card-outline-info">
            <pre><code class="python code-block"> 
get_nearest_pickup(PickupType.AMMO_UP)
get_nearest_pickup(PickupType.HEALTH_UP)</code></pre></div><br>

            Similarly, <code>get_nearest_enemy()</code> and <code>get_nearest_attackable_enemy()</code> accept an <code>EnemyType</code> as a parameter, i.e. call<br><br>

<div class="card card-outline-info">
<pre><code class="python code-block"> 
get_nearest_enemy(EnemyType.CORE_KILLER)</code></pre></div><br>

            to get the nearest visible enemy of type <code>CORE_KILLER</code>. For a full list of <code>EnemyType</code>s, check the <a href="#scripting-reference">Scripting Reference</a> below.<br><br>

            Your own character is also an entity and you can also access its attributes. The character is passed in as the first argument in your <code>update</code> function, so if your function starts with<br><br>
            <code>update(player, delta)</code><br><br>
            then you can access your own entity as <code>player</code>. Here are some attributes you might find useful:<br><br>
            <code>health</code><br>
            <code>ammo</code><br>
            <code>pos</code><br>
            <code>range_visible</code><br>
            <code>range_attackable</code><br><br>
            You would then access these for example as<br><br>
            <code>player.ammo</code><br><br>
            For a full list of attributes, check out the <a href="#scripting-reference">Scripting Reference</a> below.<br><br>

            With these functions you can actually already write a very simple AI! Here's a very basic example:<br><br>
            <div class="card card-outline-primary">
<pre><code class="python code-block"> 
def update(player, delta):
    # Find the nearest enemy, move towards it and shoot it
    nearest_enemy = get_nearest_enemy()
    move_to(nearest_enemy)
    shoot(nearest_enemy)</code></pre></div><br>
                
And that's it! Now to make it smarter, you might want to try to pick up pickups, avoid enemies if your health is low or shoot only if your ammo is high.<br><br>

        </div>
</div>

<div id="tips-and-tricks" class="card m-3" style="margin: 1.5rem">
    <div class="card-header card-inverse card-success">
    <h4> Tips and Tricks </h4>
        </div>
      <div class="card-block">
                <h4>Printing to console</h4><br>
                You might find it useful to print messages to the console. This is achieved by calling<br><br>
                <div class="card card-outline-danger">
                <pre><code class="python code-block"> 
print(message)</code></pre></div><br>

                <h4>Messages</h4><br>
                In order to cooperate with your teammates, your bot can send 'messages', to their bots. To do this, call this function:<br><br>
                <div class="card card-outline-danger">
                <pre><code class="python code-block"> 
say(string, *body)</code></pre></div><br>
                This broadcasts a message to all other players' characters. This function accepts a string and any number of other arguments that will be sent along with the message. For example, you can write:<br><br>
                <code>say('Hello World!')</code><br><br>
                To send a message with the string 'Hello World!' and no body. Alternatively, you can send<br><br>
                <code>say('Enemy Coordinates', Vector(0, 0), Vector(5, 2))</code><br><br>
                The body of the message will be a list with two elements, <code>Vector(0, 0)</code> and <code>Vector(5, 2)</code>. For convenience, if you only pass in one argument as the body, the body will be that argument itself (instead of a list with one element). In any other case, the arguments will be packed into a list.<br><br>

                
                
                In order to respond to these messages, in your script you <b>should</b> define the function<br><br>
                <div class="card card-outline-danger">
                <pre><code class="python code-block"> 
respond(player, message)</code></pre></div><br>
                which will be called when your bot receives a message. The message is an object with the following attributes:<br><br>
                <code>source</code>, the character who sent this message<br>
                <code>string</code>, the string of the message<br>
                <code>body</code>, the body of the message<br><br>
                
                Using this mechanism, you can share information with other people's bots in the middle of the game, such as enemy positions and
                coordinate your actions. This will prove invaluable when trying to clear more difficult waves.<br>
            Here's an example with messaging.<br><br>
            <div class="card card-outline-primary">
<pre><code class="python code-block">
target = None

# Response function for received messages.
def respond(player, message):
    # Need to specify that we're talking about the global variable 'target' and
    # not trying to declare a local one
    global target
    # If someone is asking for help, assume that the message's body contains
    # their entity and set that as a target.
    if message.string == 'Help':
        target = message.body
    # Otherwise if someone says they're ok, we no longer need to go to them.
    elif message.string == 'Ok':
        if target == message.body:
            target = None

def update(player, delta):
    # If our health is below 50%, call for help
    if player.health < player.healthMax / 2:
        say('Help', player)
    # Otherwise say we're ok.
    elif player.health >= player.healthMax / 2:
        say('Ok', player)

    # If someone needs help, go to them
    if target is not None:
        move_to(target)
</code></pre></div>
<br><br>
In order to use messaging effectively, you'll need to coordinate with your teammates - agree on what the message strings look like and what the message body is. <br><br>

        <h4>Attack delay and timer</h4><br>
    Your character can't shoot all the time. There is a minimum delay between every shot - by default this is 10 frames. You can access this as the attribute <code>attack_delay</code>. After your character shoots, the attribute <code>attack_timer</code> is set to the value of <code>attack_delay</code> and then every frame this timer counts down towards zero. When <code>attack_timer</code> hits zero, your character is ready to shoot again.<br><br>
In other words, while your character's <code>attack_timer</code> is above zero, calling <code>shoot()</code> does nothing - be careful since this is when your character is completely vulnerable!
Similarly, you can access the <code>attack_delay</code> and <code>attack_timer</code> attributes of your enemies - can you use that information to your advantage?
    </div>
    </div>

  <div id="scripting-reference" class="card m-3" style="margin: 1.5rem">
      <div class="card-header card-inverse card-success">
        <h4> Scripting Reference </h4>
        </div>
        <div class="card-block">
        <div class="card card-outline-danger">
        <pre><code class="python code-block">
update(player, delta)</code></pre></div><br>
        <b>Must</b> be defined. This function is called each frame (30 times per second).<br>
        <code>player</code> - current player's entity<br>
        <code>delta</code> - time in seconds since the last frame<br>
        <br>
        <div class="card card-outline-danger">
        <pre><code class="python code-block">
respond(player, message)</code></pre></div><br>
        <b>Should</b> be defined. This function is called whenever some player calls <code>say()</code>. If this function is not defined, the default behaviour is to do nothing when a message is received.<br>
        <code>player</code> - current player's entity<br>
        <code>message</code> - message object that was received<br>
        <br>
        <b>The following libraries can be used without having to <code>import</code> them.</b><br>
        <code>math</code><br>
        <code>random</code><br>
        <code>sys</code><br><br>
        
        <b>The following built in keywords are allowed</b>:<br>
        <code>abs</code>, <code>all</code>, <code>any</code>, <code>ascii</code>, <code>bin</code>, <code>bool</code>, <code>bytearray</code>, <code>bytes</code>, <code>callable</code>, <code>chr</code>, <code>classmethod</code>, <code>complex</code>, <code>delattr</code>, <code>dict</code>, <code>dir</code>, <code>divmod</code>, <code>enumerate</code>, <code>filter</code>, <code>float</code>, <code>format</code>, <code>frozenset</code>, <code>getattr</code>, <code>globals</code>, <code>hasattr</code>, <code>hash</code>, <code>help</code>, <code>hex</code>, <code>id</code>, <code>int</code>, <code>isinstance</code>, <code>issubclass</code>, <code>iter</code>, <code>len</code>, <code>list</code>, <code>locals</code>, <code>map</code>, <code>max</code>, <code>min</code>, <code>next</code>, <code>object</code>, <code>oct</code>, <code>ord</code>, <code>pow</code>, <code>property</code>, <code>range</code>, <code>repr</code>, <code>reversed</code>, <code>round</code>, <code>set</code>, <code>setattr</code>, <code>slice</code>, <code>sorted</code>, <code>staticmethod</code>, <code>str</code>, <code>sum</code>, <code>super</code>, <code>tuple</code>, <code>type</code>, <code>vars</code>, <code>zip
            </code>
        <br><br>
        Note that <code>import</code> is not allowed for security reasons.<br><br>

        <b>The following lists can be accessed</b>:<br>
        <code class="code_main">enemies_visible</code> - 
        Contains enemies within the player's visible range (given by <code>range_visible</code>).<br>
        <code class="code_main">enemies_attackable</code> - 
        Contains enemies within the player's attackable range (given by <code>range_attackable</code>).<br>
        <code class="code_main">pickups_visible</code> - 
        Contains pickups within the player's visible range (given by <code>range_visible</code>).<br><br>

        <b>Can access</b><br>
        <code>core</code><br><br>

        <b>Base entity attributes</b><br>
        <code class="code-main">tag</code> - identification number of given entity.<br>
        <code class="code-main">pos</code> - position vector of given entity.<br>
        <code class="code-main">vel</code> - velocity vector of given entity.<br>
        <code class="code-main">speed</code> - maximum speed of given entity.<br>
        <code class="code-main">size</code> - size vector of given entity.<br>
        <code class="code-main">healthMax</code> - maximum health of given entity.<br>
        <code class="code-main">health</code> - current health of given entity.<br><br>

        <b>Player attributes</b><br>
        <a data-toggle="collapse" class="clink" data-target="#p-entity">Inherited from Entity (click to collapse)</a>
        <div class="collapse" id="p-entity">
        <code class="code-main">tag</code> - identification number of given entity.<br>
        <code class="code-main">pos</code> - position vector of given entity.<br>
        <code class="code-main">vel</code> - velocity vector of given entity.<br>
        <code class="code-main">speed</code> - maximum speed of given entity.<br>
        <code class="code-main">size</code> - size vector of given entity.<br>
        <code class="code-main">healthMax</code> - maximum health of given entity.<br>
        <code class="code-main">health</code> - current health of given entity.<br><br>
        </div><br>

        Unique:<br>
        <code>name</code><br>
        <code>color</code><br>
        <code>ammo</code><br>
        <code>speed</code><br>
        <code>damage</code><br>
        <code>range_visible</code><br>
        <code>range_attackable</code><br>
        <code>attack_delay</code><br>
        <code>attack_timer</code><br><br>

        <b>Enemy attributes</b><br>
        Inherited from Entity:<br>
        <code>tag</code><br>
        <code>pos</code><br>
        <code>vel</code><br>
        <code>speed</code><br>
        <code>size</code><br>
        <code>healthMax</code><br>
        <code>health</code><br><br>

        Unique:<br>
        <code>enemy_type</code><br>
        <code>is_boss</code><br>
        <code>range_visible</code><br>
        <code>range_attackable</code><br>
        <code>attack_delay</code><br>
        <code>attack_timer</code><br><br>

        <b>Pickup attributes</b><br>
        Inherited from Entity:<br>
        <code>tag</code><br>
        <code>pos</code><br>
        <code>vel</code><br>
        <code>speed</code><br>
        <code>size</code><br>
        <code>healthMax</code><br>
        <code>health</code><br><br>

        Unique:<br>
        <code>pickup_type</code><br>
        <code>value</code><br><br>

        <b><code>print(message)</code></b><br>
        <b><code>shoot(enemy)</code></b><br>
        <b><code>get_nearest_enemy(enemy_type=None)</code></b><br>
        <code>get_nearest_attackable_enemy(enemy_type=None)</code><br>
        <b><code>get_nearest_pickup(pickup_type=None)</code></b><br>
        <b><code>say(string, *body)</code></b><br>
        <code>say_also_to_self(string, *body)</code><br>
        <code>distance_to(target)</code><br>
        <b><code>move_to(target, speed=None)</code></b><br>
        <code>move_from(target, speed=None)</code><br>
        <code>get_nearest(entities, with_distance=False)</code><br>
        <code>get_farthest(entities, with_distance=False)</code><br><br>

        <b>Message:</b><br>
        <b><code>source</code></b><br>
        <code>to_self</code><br>
        <code>string</code><br>
        <code>body</code><br>

        <b>Vectors:</b><br>
        Initialise as:<br>
        <code>Vector(x, y)</code><br><br>
        Vector functions:<br>
        <code>DistanceSqrd(point1, point2)</code><br>
        <code>Distance(point1, point2)</code><br>
        <code>LengthSqrd(vec)</code><br>
        <code>Length(vec)</code><br>
        <code>Normalize(vec)</code><br>
        <code>Dot(a, b)</code><br>
        <code>ProjectOnto(w, v)</code><br><br>

        PickupType<br>
        <code>AMMO_UP</code><br>
        <code>HEALTH_UP</code><br><br>

        EnemyType<br>
        <code>DEFAULT</code><br>
        <code>CORE_KILLER</code><br>
        <code>PLAYER_KILLER</code><br>
	<br>
    </div>
        </div>
        </div>

	<center>
        <a class="btn btn-lg btn-success" href="{{ url_for('.home') }}">Let's play!</a>
	</center>
  </div>
{% endblock %}
